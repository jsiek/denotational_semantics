\documentclass[12pt]{beamer}
%\usecolortheme{seagull}
%\usecolortheme{wolverine} yuk
%\usecolortheme{beetle}
\usecolortheme{dove} % black on white
\usepackage[T1]{fontenc}
\usepackage{garamond}
\usefonttheme{serif}
\usepackage{multicol}
\usepackage{pifont}
\usepackage{etex}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{semantic}
\usepackage[all]{xy}
\usepackage{color}
\usepackage{listings}
\usepackage{fancybox}
\usepackage{stmaryrd}
\usepackage{rotating}
\usepackage{wasysym}
\usepackage{ulem}

\definecolor{darkgreen}{rgb}{0.0, 0.6, 0.3}

\usepackage{enumitem}
\setitemize{label=\usebeamerfont*{itemize item}%
  \usebeamercolor[fg]{itemize item}
  \usebeamertemplate{itemize item}}
  \setlist{itemsep=1ex}



\newcommand{\Gbox}[1]{\colorbox{lightgray}{#1}}
\newcommand{\Rbox}[1]{\colorbox{pink}{#1}}

\newcommand{\featstart}{\hfill}
\newcommand{\featend}{\hfill\hfill}
\newcommand{\feat}[1]{{\featstart#1\featend}}

\newcommand{\Topcircle}{\begin{turn}{270}\Leftcircle\end{turn}}
\newcommand{\BOTTOMCIRCLE}{\begin{turn}{270}\RIGHTCIRCLE\end{turn}}
\newcommand{\halfcircle}{\parbox{0in}{\Topcircle}\parbox{1.65ex}{\BOTTOMCIRCLE}{}}

\newcommand{\featY}{\feat{\CIRCLE}} % Has feature fully
\newcommand{\featP}{\feat{\halfcircle}} % Has feature partially
\newcommand{\featN}{\feat{\Circle}} % Does not have feature


\newcommand{\labeltag}[1]{\label{#1}\tag{\textsc{#1}}}
\newcommand{\type}{\vdash}
\newcommand{\typeS}{\vdash_{STLC}}
\newcommand{\typeG}{\vdash}
\newcommand{\typeCC}{\vdash_{C}}

\newcommand{\evall}{\Downarrow }
\newcommand{\evallS}{\Downarrow_{STLC} }
\newcommand{\evallG}{\Downarrow}
\newcommand{\evallCC}{\Downarrow_{C}}
\newcommand{\evallD}{\Downarrow_{DTLC}}

\newcommand{\reduce}{\longrightarrow}
\newcommand{\becomes}{\longrightarrow}

%\newcommand{\EE}{{\cal E}}
%\newcommand{\FF}{{\cal F}}
\newcommand{\Hole}{\Box}

\newcommand{\divergeG}{\Uparrow}
\newcommand{\subtype}{<:}
\newcommand{\consis}{\sim}

\newcommand{\embed}[1]{\lceil #1 \rceil}
\newcommand{\bl}[1]{{\color{blue} #1}}
\newcommand{\rd}[1]{{\color{red} #1}}
\newcommand{\pr}[1]{{\color{purple} #1}}
\newcommand{\kw}[1]{\mathtt{#1}}

\newcommand{\labels}[1]{\mathit{labels}(#1)}
\newcommand{\static}[2]{\mathit{static}(#1,#2)}
\newcommand{\safe}[1]{\mathrel{\mathit{safe}} #1}
\newcommand{\lo}[1]{\overline{#1}}
\newcommand{\rng}[1]{\mathit{rng}(#1)}

\newcommand{\semi}{\mathbin{;}}
\newcommand{\id}{\key{id}}
\newcommand{\Id}[1]{\id_{#1}}
\newcommand{\fail}[3]{\bot^{#1}_{#2 \Rightarrow #3}}
\newcommand{\Fail}[1]{\bot^{#1}}
\newcommand{\FAIL}[3]{\bot^{#2}}
\newcommand{\qu}[2]{{{#2}\query^{#1}}}
\newcommand{\pl}[1]{{#1\pling}}
\newcommand{\query}{\mathtt{?}}
\newcommand{\pling}{\mathtt{!}}

\newcommand{\bcfun}[1]{\langle\!\langle #1 \rangle\!\rangle}
\newcommand{\MergeT}{\sqcap}
\newcommand{\RefC}[1]{\key{Ref}(#1)}
\newcommand{\error}{\key{error}}


\newcommand{\Obj}{\key{Obj}}
\newcommand{\String}{\key{String}}
\newcommand{\Double}{\key{Double}}

%\newcommand{\If}[3]{\key{if}\,#1\key{if}\,#2\key{if}#3}


\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}
\newenvironment{stack}{\ba{@{}l@{}}}{\ea}
\newenvironment{branch}{\left\{\ba{@{}l@{\qquad}l@{}}}{\ea\right\}}
\newenvironment{syntax}{\[\ba{l@{\;\;}lcl}}{\ea\]}
\newcommand{\dotspace}{.\,}
\newcommand{\key}[1]{\ensuremath{\mathtt{#1}}}
\newcommand{\Base}{B}
\newcommand{\dyn}{\star}
\newcommand{\Dyn}{\ensuremath{\star}}
\newcommand{\Int}{\key{Int}}
\newcommand{\Float}{\key{float}}
\newcommand{\Bool}{\key{Bool}}
\newcommand{\Str}{\key{String}}
\newcommand{\Ref}{\key{Ref}\,}
\newcommand{\tapp}{\;\,}
\newcommand{\tu}{{\to}}
\newcommand{\To}{\Rightarrow}
\newcommand{\Let}{\key{let}\;}
\newcommand{\Letrec}{\key{let}\,\key{rec}\;}
\newcommand{\In}{\key{in}\;}
\newcommand{\If}{\mathsf{if}\;}
\newcommand{\Then}{\;\mathsf{then}\;}
\newcommand{\Else}{\mathsf{else}\;}
\newcommand{\True}{\key{true}}
\newcommand{\False}{\key{false}}
\newcommand{\as}{\mathrel{\key{as}}}
\newcommand{\op}{\mathit{op}}
\newcommand{\dom}[1]{\mathit{dom}(#1)}
\newcommand{\cod}[1]{\mathit{cod}(#1)}
\newcommand{\blame}[1]{\key{blame}\,#1}
\newcommand{\pblame}[2]{\key{blame}\,#1@#2}
\newcommand{\ledyn}{\sqsubseteq}
\newcommand{\IS}{\mathrel{\mathtt{is}}}
\newcommand{\cast}[1]{\overset{#1}{\Rightarrow}}
%\newcommand{\mkcast}[1]{\langle\!\langle#1\rangle\!\rangle}
\newcommand{\mkcast}[1]{(#1)}
\newcommand{\alloc}{\key{ref}\,}
\newcommand{\deref}{\texttt{!}}
\newcommand{\update}{\mathrel{\texttt{:=}}}
\newcommand{\all}[1]{\forall #1.\,}
\newcommand{\ftv}[1]{\mathrm{ftv}(#1)}
\newcommand{\CAST}[1]{\langle #1 \rangle}
\newcommand{\new}[1]{\nu #1.\;}
\newcommand{\case}[3]{\key{case}\,#1\,\key{of}\,\key{inl}\,x\Rightarrow\,#2\,| \,\key{inr}\,x\Rightarrow \,#3}
\newcommand{\join}[2]{#1 \sqcup #2 }
\newcommand{\meet}[2]{#1 \sqcap #2 }

\newcommand{\EE}[2]{\mathcal{E}\llbracket #1 \rrbracket #2}
\newcommand{\FF}[3]{\mathcal{F}(#1, #2, #3)}
\newcommand{\CC}[1]{\mathcal{C}\llbracket #1 \rrbracket}

\newcommand{\EXP}[1]{\,#1\,}
\newcommand{\CE}[0]{\mathcal{E}}
\newcommand{\SEM}[1]{\llbracket #1 \rrbracket}
\newcommand{\ESEM}[1]{\llbracket #1 \rrbracket}
\newcommand{\TSEM}[1]{\mathcal{T}\llbracket #1 \rrbracket}
\newcommand{\lam}[1]{\lambda #1.\,}
\newcommand{\LAM}[1]{\lambda\!\!\!\lambda #1.\,}
\newcommand{\of}[0]{{:}}
\newcommand{\by}[0]{{:=}}
\newcommand{\INT}[0]{\mathtt{int}}
\newcommand{\REF}[1]{\mathtt{ref}\,#1}
\newcommand{\fix}[1]{\mathtt{fix}\,#1.\,}
\newcommand{\FST}[1]{\pi_1\, #1}
\newcommand{\SND}[1]{\pi_2\, #1}
\newcommand{\fst}[1]{\mathsf{fst}(#1)}
\newcommand{\snd}[1]{\mathsf{snd}(#1)}
\newcommand{\emptyenv}[0]{\mathsf{empty}}
\newcommand{\ext}[3]{\mathsf{extend}(#1,#2,#3)}
\newcommand{\tyext}[1]{\mathsf{tyExtend}(#1)}
\newcommand{\lookup}[2]{\mathsf{lookup}(#1,#2)}
\newcommand{\shift}[3]{\,\uparrow^{#1}_{#2}(#3)}
\newcommand{\app}[0]{\;}
\newcommand{\LET}[0]{\mathbf{let}\,}
\newcommand{\IN}[0]{\,\mathbf{in}\,}
\newcommand{\abs}[1]{\mathsf{thunk}(#1)}
\newcommand{\val}[1]{\overline{#1}}
\newcommand{\CASE}[0]{\textsf{case}\,}
\newcommand{\OF}[0]{\,\textsf{of}\,}
%% \newcommand{\IF}[0]{\textbf{if}\,}
%% \newcommand{\THEN}[0]{\,\textbf{then}\,}
%% \newcommand{\ELSE}[0]{\,\textbf{else}\,}
\newcommand{\IF}[0]{\mathsf{ifz}(}
\newcommand{\THEN}[0]{,}
\newcommand{\ELSE}[0]{,}
\newcommand{\FI}[0]{)}
\newcommand{\return}[0]{\mathsf{return}\;}
\newcommand{\bind}[0]{\mathsf{bind}\;}
\newcommand{\down}[0]{\mathsf{down}\;}
\newcommand{\wrong}[0]{\mathsf{wrong}}
\newcommand{\plus}[0]{\mathrel{\mathsf{plus}}}
\newcommand{\zero}[0]{\mathsf{zero}}
\newcommand{\SET}[1]{\mathcal{P}(#1)}
\newcommand{\FSET}[1]{\mathcal{P}_f(#1)}
\newcommand{\store}[0]{\mathsf{store}}
\newcommand{\CHOOSE}[0]{\mathsf{choose}\,}

\newcommand*\oldmacro{}%
\let\oldmacro\insertshorttitle%
\renewcommand*\insertshorttitle{%
  \oldmacro\hfill%
  \insertframenumber\,/\,\inserttotalframenumber}

\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{footline}[frame number]

%\newtheorem{definition}{Definition}
\newtheorem{conjecture}[theorem]{\translate{Conjecture}}
\newtheorem{proposition}[theorem]{\translate{Proposition}}

\lstdefinestyle{basic}{
%showstringspaces=false,
language=Python,
columns=fullflexible,
%basicstyle=\sffamily\small,%
basicstyle=\ttfamily,%
%columns=fixed,
%basewidth=0.49em,
%lineskip=0pt,
%escapechar=@,xleftmargin=1pc,%
keywordstyle=\ttfamily,
mathescape=true,%
moredelim=**[is][\color{blue}]{@}{@},
moredelim=[is][\color{red}]{|}{|},
moredelim=[is][\color{blue}]{~}{~},
%commentstyle=\rmfamily,%
%morekeywords={return,fix,var,proc,fun,func},%
%deletekeywords={int,bool}
}
\lstset{style=basic}

\garamond

\title[Back to Denotational]{Back to the Future with \\ Denotational Semantics}
\author{Jeremy G. Siek \\[1ex]
 Indiana University, Bloomington
}
\date{}
%% \institute{\normalsize 
%%  Indiana University, Bloomington
%% }

% 3 hours

%\newcommand\footnotemark{}
%\renewcommand\footnoterule{}
\setbeamercolor{footnote mark}{fg=white}

\begin{document}

\frame{

%% \begin{tabular}{ll} 
%% \begin{minipage}{0.45\textwidth}
\centering
\large Intersection Types, Sub-formula Property, and  \\ 
   the Functional Character of the Lambda Calculus \\[2ex]
\normalsize Jeremy G. Siek \\
Indiana University\\[2ex]
PL Wonks \\
August 2018
%% \end{minipage}
%% &
%% \begin{minipage}{0.45\textwidth}
%% \includegraphics[height=3in]{btf}
%% \end{minipage}
%% \end{tabular}

}
%===============================================================================
\frame{

}

%===============================================================================

\frame{
\frametitle{Outline}
\begin{itemize}
\item ...
\end{itemize}
}


%===============================================================================

\frame{
\frametitle{Tabulating Functions}

Syntax of an applied lambda calculus:
\[
  \begin{array}{rcl}
  && n \in \mathbb{Z} \qquad x \in \mathbb{X} \;\;\text{(program variables)}\\
  e \in \mathbb{E} & ::= & x \mid \lam{x} e \mid e \; e \mid \\
  & & n \mid e \oplus e \mid \IF e \THEN e \ELSE e  \FI\\
  v & ::= & n \mid \lam{x} e \\
  \oplus & ::= & + \mid - \mid \times 
  \end{array}
\]

Denotations:
\begin{center}
  \fbox{\fbox{
      $
      \begin{array}{ll}
      d ::= n \mid \{ d_1\mapsto d'_1,\ldots, d_n\mapsto d'_n \}\\[1ex]
      \mathbb{D} = \mathbb{Z} + \mathcal{P}_{f}(\mathbb{D} \times \mathbb{D})
      \end{array}
      $
}}
\end{center}

Let $t$, for table, range over $\mathcal{P}_{f}(\mathbb{D} \times \mathbb{D}) $.

}

%===============================================================================
\frame{
\frametitle{A Compositional Big-Step Semantics}
\small
\fbox{$\rho \vdash e \Rightarrow d$}
\begin{gather*}
  \inference
      { d \sqsubseteq \rho(x)}
      {\rho \vdash x \Rightarrow d}
  \;
  \inference
      {\forall d\mapsto d'\in t,\\ \rho(x{:=}d) \vdash e \Rightarrow d'}
      {\rho \vdash \lam{x}e \Rightarrow t}
  \;
  \inference
      {\rho \vdash e_1 \Rightarrow t &
       \rho \vdash e_2 \Rightarrow d_2 \\
      d \mapsto d' \in t & d \sqsubseteq d_2 & d_3 \sqsubseteq d'}
      {\rho \vdash (e_1\app e_2) \Rightarrow d_3}
  \\[2ex]
  \inference{}{\rho \vdash n \Rightarrow n}
  \qquad
  \inference
      {\rho \vdash e_1 \Rightarrow n_1 &
       \rho \vdash e_2 \Rightarrow n_2}
      {\rho \vdash e_1 \oplus e_2 \Rightarrow n_1 \oplus n_2}
  \\[2ex]
  \inference{\rho \vdash e_1 \Rightarrow 0 & 
    \rho \vdash e_2 \Rightarrow d}
            {\rho \vdash \IF e_1 \THEN e_2 \ELSE e_3 \FI \Rightarrow d}
  \;
  \inference{\rho \vdash e_1 \Rightarrow n & n \neq 0 &
    \rho \vdash e_3 \Rightarrow d}
            {\rho \vdash \IF e_1 \THEN e_2 \ELSE e_3 \FI \Rightarrow d}
\end{gather*}
\hrule
\hrule
\vspace{5pt}
Comparison to a standard big-step semantics:
\begin{gather*}
  \inference{}
            {\varrho \vdash \lam{x} e \Rightarrow \langle \lam{x}e,\varrho \rangle}
  \qquad
  \inference{\varrho \vdash e_1 \Rightarrow \langle \lam{x}e,\varrho' \rangle&
             \varrho \vdash e_1 \Rightarrow v_2 \\
             \varrho'(x\by v_2) \vdash e \Rightarrow v}
            {\varrho \vdash (e_1 \app e_2) \Rightarrow v}
\end{gather*}
}
%===============================================================================
\frame{
\frametitle{The Semantics in Denotational Form}

Of course, relations are isomorphic to set-valued functions:
\[
  \SET{(\mathbb{X} \to \mathbb{D}) \times \mathbb{E} \times \mathbb{D}}
  \quad\cong\quad
  \mathbb{E} \to (\mathbb{X} \to \mathbb{D}) \to \SET{\mathbb{D}}
\]

}

%===============================================================================

\frame{
\frametitle{The Semantics in Denotational Form}

\fbox{$\SEM{-}: \mathbb{E} \to (\mathbb{X} \to \mathbb{D}) \to \SET{\mathbb{D}}$}
\begin{align*}
\SEM{ n }\rho &= \{ n \} \\
\SEM{ e_1 \oplus e_2 }\rho &= \{  n_1 \oplus n_2 \mid 
   n_1 \in \SEM{ e_1 }\rho \text{ and } n_2 \in \SEM{ e_2 }\rho \} \\
\SEM{ x }\rho &= \{ d \mid d \sqsubseteq \rho(x) \} \\
\SEM{ \lam{x} e }\rho &= 
  \{ t \mid \forall d\mapsto d'\in t,\, d' \in \SEM{ e }\rho(x{:=}d) \} \\
\SEM{ e_1\;e_2 }\rho &= \left\{ d_3 \, \middle| 
   \begin{array}{l}
   \exists t\, d_2\, d\, d'.\, t \in \SEM{ e_1 }\rho,\, d_2 \in \SEM{ e_2 }\rho, \\
   d\mapsto d' \in t, \, d \sqsubseteq d_2,\, d_3 \sqsubseteq d'
   \end{array}
\right\} \\
\SEM{\IF e_1 \THEN e_2 \ELSE e_3 \FI}\rho &=
\left\{ d\, \middle|\,
  \begin{array}{l}
   \exists n.\, n \in \SEM{e_1}\rho, \\
   \quad (n= 0 \implies d \in \SEM{e_2}\rho) \text{ and}\\
   \quad (n\neq 0 \implies d \in \SEM{e_3}\rho)
  \end{array}
  \right\}
\end{align*}

}

%===============================================================================
\frame{
\frametitle{$\beta_v$-reduction}

\textbf{Theorem} (Equality of $\beta_v$-reduction)
\[
\SEM{(\lam{x}e) \app v} = \SEM{e[v/x]}
\]

One direction of the proof relies on \\[2ex]

\textbf{Lemma}  (Reverse Substitution)\\
  If $d \in \SEM{e[v/x]}$ then
  $\exists d' \in \SEM{v}\emptyset,\; d \in \SEM{e}\rho(x{:=}d')$.\\[2ex]

which in turn relies on \\[2ex]

\textbf{Lemma} (Combine Denotations of Values)\\
If $d_1 \in \SEM{v}\rho$ and $d_2 \in \SEM{v}\rho$,
then $d_1 \sqcup d_2 \in \SEM{v}\rho$.


}

%===============================================================================

\frame{
\frametitle{Goal: arbitrary $\beta$-reduction}

\textbf{Theorem} (Equality of $\beta$-reduction for CBV)\\
\[
\SEM{(\lam{x}e) \app e'} = \SEM{e[e'/x]}
\qquad \text{if } \SEM{e'} \neq \emptyset
\]
\vspace{5pt}

This requires\\[2ex]

\textbf{Lemma} (Combine Denotations of Expressions)\\
If $d_1 \in \SEM{e}\rho$ and $d_2 \in \SEM{e}\rho$,
then $d_1 \sqcup d_2 \in \SEM{e}\rho$.

}

%===============================================================================
\frame{
   \frametitle{Tables are Relations, not Functions}

A problem with the lambda's-as-tables approach:
\begin{align*}
  \lam{f} (f \app 3) + (f \app 3)
  &=_{\mathrm{ctx}}
  \lam{f} (\lam{x} x + x) \app (f \app 3)
\\
  \ESEM{\lam{f} (f \app 3) + (f \app 3)}
  &\neq
  \ESEM{\lam{f} (\lam{x} x + x) \app (f \app 3)}
\end{align*}

Why not equal?
\begin{align*}
  R &= \{ 0\mapsto 1, 0\mapsto 2 \}\\
  \{ R\mapsto 9 \} &\in \ESEM{\lam{f} (f \app 3) + (f \app 3)} \\
  \{ R\mapsto 9 \} &\not\in \ESEM{\lam{f} (\lam{x} x + x) \app (f \app 3)} 
\end{align*}
   
This is bad, we need this equality to justify a standard compiler
optimization: common subexpression elimination!

}
%===============================================================================
\frame{
  \frametitle{Restrict the tables to be functions}

  \begin{itemize}
    \item Recall the definition: a \textbf{function} $f$ is a relation
      such that\\
      if $(a,b) \in f$ and $(a,b') \in f$, then $b = b'$.
    \item Can we add this restriction to the denotations?
    \item Not quite, it would allow bogus tables such as
      \[
      \{ \{0\mapsto 1\} \mapsto 2, \{0\mapsto 1, 5\mapsto 6 \} \mapsto 3 \}
      \]   
  \end{itemize}

  We need a generalization of equality that makes sense for
  approximations of functions.
  
\begin{gather*}
  \frac{}{n \sim n}
  \qquad
  \frac{\begin{array}{l}\forall d_1 d'_1 d_2 d'_2, d_1\mapsto d'_1 \in t_1 \land d_2 \mapsto d'_2 \in t_2 \\
        \implies (d_1 \sim d_2 \land d'_1 \sim d'_2) \lor d_1 \not\sim d_2
        \end{array}}
    {t_1 \sim t_2}
\end{gather*}

}
%===============================================================================
\frame{
  \frametitle{Determinism}

  With this restriction, I was able to prove the following in December
  of 2017. \\[2ex]

  \textbf{Theorem} (Determinism)\\ If $d_1 \in \SEM{e}\rho$ and $d_2
  \in \SEM{e}\rho$ , then $d_1 \sim d_2$. \\[2ex]

  In general for partial orders, one often has
  \[
    a \sim b \text{ iff } \exists c,\; c = a \sqcup b
  \]
  So I thought that the lemma Combine Denotations of Expressions would
  easily follow. \\[2ex]

  It didn't.
}
%===============================================================================
\frame{
  \frametitle{Challenge \#1}


  I had been using the follow definition of $\sqsubseteq$
  \[
    \inference{}{n \sqsubseteq n}
    \qquad
    \inference{t_1 \subseteq t_2}
               {t_1 \sqsubseteq t_2}
  \]
  which leads to this definition of $\sqcup$:
  \begin{align*}
    n \sqcup n &= n \\
    t_1 \sqcup t_2 &= t_1 \cup t_2
  \end{align*}
    
}

%===============================================================================

\frame{
  \frametitle{Challenge \#1}
  
Let's try to prove Combine Denoations of Expression by induction on
$e$. Consider the case for application: $e = (e_1 \app e_2)$. From $v
\in \ESEM{e_1 \app e_2}\rho$ and $v' \in \ESEM{e_1 \app e_2}\rho'$ we
have something like
\begin{gather*}
t \in \ESEM{e_1}\rho \qquad v_2 \in \ESEM{e_2}\rho \qquad
  v_2 \mapsto v \in t \\
t' \in \ESEM{e_2}\rho' \qquad v'_2 \in \ESEM{e_2}\rho' \qquad
  v'_2 \mapsto v' \in t
\end{gather*}
By the induction hypothesis we have
\[
t \sqcup t' \in \ESEM{e_1} \qquad
v_2 \sqcup v'_2 \in \ESEM{e_2}
\]
We need to show that 
\[
   (v_2 \sqcup v'_2) \mapsto (v \sqcup v') \in t \sqcup t' 
\]
But we cannot. Set union does not mix together information from
entries in $t$ and $t'$ to form new entries.

}

%===============================================================================

\frame{
  \frametitle{Solution \#1: Intersection Types}

  Our domain $\mathbb{D}$ and ordering $\sqsubseteq$ can be viewed as
  a certain kind of intersection type.
  

}


\end{document}

% LocalWords:  titlepage containsverbatim frametitle  Siek Taha lstlisting
% LocalWords:  Rightarrow IU CBV Denotational SECD Landin Plotkin et
% LocalWords:  texttt Rightarrow texttt texttt Rightarrow Findler deriv Wadler
% LocalWords:  Longrightarrow Longrightarrow circ Wrigstad ldots inc bytecode
% LocalWords:  includegraphics invokedynamic switchpoints unboxed xymatrix rrr
% LocalWords:  vspace newsavebox DistExample lrbox linewidth mathtt mathtt emph
% LocalWords:  vdash usebox mathbf mathit longmapsto mathsf subtyping emptyset
% LocalWords:  Henglein's footnotesize Drossopoulou Igarashi Gronski Dimoulas
% LocalWords:  varphi eval Jython microbenchmarks Fibonnaci vitousek bharadwaj
% LocalWords:  Shashank  Barendregt al Coppo Dezani Salle Damas Rees
%%  LocalWords:  Felleisen Compositional denotational rcl de Atkey AO
%%  LocalWords:  lcl lccl Heh subsumption wrt Abramsky's btw BCDC BCD
%%  LocalWords:  CDCHL Abramsky BDS iff Inhabitation CDHL HL Bool FV
%%  LocalWords:  darkgreen Egidi Honsell Ronchi Rocca preorder Alessi
%%  LocalWords:  Barbanera Ciancaglini nts dom Sem approximants ctx
%%  LocalWords:  Hyland CDS polymorphism
