\documentclass[12pt]{beamer}
%\usecolortheme{seagull}
%\usecolortheme{wolverine} yuk
%\usecolortheme{beetle}
\usecolortheme{dove} % black on white
\usepackage[T1]{fontenc}
%\usepackage{garamond}
%\usefonttheme{serif}
\usepackage{multicol}
\usepackage{pifont}
\usepackage{etex}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
%\usepackage{revsymb}
\usepackage{semantic}
\usepackage[all]{xy}
\usepackage{color}
\usepackage{listings}
\usepackage{fancybox}
\usepackage{stmaryrd}
\usepackage{rotating}
\usepackage{wasysym}
\usepackage{ulem}
%\usepackage{txfonts}

\definecolor{darkgreen}{rgb}{0.0, 0.6, 0.3}

\usepackage{enumitem}
\setitemize{label=\usebeamerfont*{itemize item}%
  \usebeamercolor[fg]{itemize item}
  \usebeamertemplate{itemize item}}
  \setlist{itemsep=1ex}


\setbeamersize{text margin left=5mm,text margin right=5mm}
  
\newcommand{\Gbox}[1]{\colorbox{lightgray}{#1}}
\newcommand{\Rbox}[1]{\colorbox{pink}{#1}}

\newcommand{\featstart}{\hfill}
\newcommand{\featend}{\hfill\hfill}
\newcommand{\feat}[1]{{\featstart#1\featend}}

\newcommand{\Topcircle}{\begin{turn}{270}\Leftcircle\end{turn}}
\newcommand{\BOTTOMCIRCLE}{\begin{turn}{270}\RIGHTCIRCLE\end{turn}}
\newcommand{\halfcircle}{\parbox{0in}{\Topcircle}\parbox{1.65ex}{\BOTTOMCIRCLE}{}}

\newcommand{\featY}{\feat{\CIRCLE}} % Has feature fully
\newcommand{\featP}{\feat{\halfcircle}} % Has feature partially
\newcommand{\featN}{\feat{\Circle}} % Does not have feature


\newcommand{\labeltag}[1]{\label{#1}\tag{\textsc{#1}}}
\newcommand{\type}{\vdash}
\newcommand{\typeS}{\vdash_{STLC}}
\newcommand{\typeG}{\vdash}
\newcommand{\typeCC}{\vdash_{C}}

\newcommand{\evall}{\Downarrow }
\newcommand{\evallS}{\Downarrow_{STLC} }
\newcommand{\evallG}{\Downarrow}
\newcommand{\evallCC}{\Downarrow_{C}}
\newcommand{\evallD}{\Downarrow_{DTLC}}

\newcommand{\reduce}{\longrightarrow}
\newcommand{\becomes}{\longrightarrow}

%\newcommand{\EE}{{\cal E}}
%\newcommand{\FF}{{\cal F}}
\newcommand{\Hole}{\Box}

\newcommand{\divergeG}{\Uparrow}
\newcommand{\subtype}{<:}
\newcommand{\consis}{\sim}

\newcommand{\embed}[1]{\lceil #1 \rceil}
\newcommand{\bl}[1]{{\color{blue} #1}}
\newcommand{\rd}[1]{{\color{red} #1}}
\newcommand{\pr}[1]{{\color{purple} #1}}
\newcommand{\gr}[1]{{\color{darkgreen} #1}}
\newcommand{\kw}[1]{\mathtt{#1}}

\newcommand{\labels}[1]{\mathit{labels}(#1)}
\newcommand{\static}[2]{\mathit{static}(#1,#2)}
\newcommand{\safe}[1]{\mathrel{\mathit{safe}} #1}
\newcommand{\lo}[1]{\overline{#1}}
\newcommand{\rng}[1]{\mathit{rng}(#1)}

\newcommand{\semi}{\mathbin{;}}
\newcommand{\id}{\key{id}}
\newcommand{\Id}[1]{\id_{#1}}
\newcommand{\fail}[3]{\bot^{#1}_{#2 \Rightarrow #3}}
\newcommand{\Fail}[1]{\bot^{#1}}
\newcommand{\FAIL}[3]{\bot^{#2}}
\newcommand{\qu}[2]{{{#2}\query^{#1}}}
\newcommand{\pl}[1]{{#1\pling}}
\newcommand{\query}{\mathtt{?}}
\newcommand{\pling}{\mathtt{!}}

\newcommand{\bcfun}[1]{\langle\!\langle #1 \rangle\!\rangle}
\newcommand{\MergeT}{\sqcap}
\newcommand{\RefC}[1]{\key{Ref}(#1)}
\newcommand{\error}{\key{error}}


\newcommand{\Obj}{\key{Obj}}
\newcommand{\String}{\key{String}}
\newcommand{\Double}{\key{Double}}

%\newcommand{\If}[3]{\key{if}\,#1\key{if}\,#2\key{if}#3}


\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}
\newenvironment{stack}{\ba{@{}l@{}}}{\ea}
\newenvironment{branch}{\left\{\ba{@{}l@{\qquad}l@{}}}{\ea\right\}}
\newenvironment{syntax}{\[\ba{l@{\;\;}lcl}}{\ea\]}
\newcommand{\dotspace}{.\,}
\newcommand{\key}[1]{\ensuremath{\mathtt{#1}}}
\newcommand{\Base}{B}
\newcommand{\dyn}{\star}
\newcommand{\Dyn}{\ensuremath{\star}}
\newcommand{\Int}{\key{Int}}
\newcommand{\Float}{\key{float}}
\newcommand{\Bool}{\key{Bool}}
\newcommand{\Str}{\key{String}}
\newcommand{\Ref}{\key{Ref}\,}
\newcommand{\tapp}{\;\,}
\newcommand{\tu}{{\to}}
\newcommand{\To}{\Rightarrow}
\newcommand{\Let}{\key{let}\;}
\newcommand{\Letrec}{\key{let}\,\key{rec}\;}
\newcommand{\In}{\key{in}\;}
\newcommand{\If}{\mathsf{if}\;}
\newcommand{\Then}{\;\mathsf{then}\;}
\newcommand{\Else}{\mathsf{else}\;}
\newcommand{\True}{\key{true}}
\newcommand{\False}{\key{false}}
\newcommand{\as}{\mathrel{\key{as}}}
\newcommand{\op}{\mathit{op}}
\newcommand{\dom}[1]{\mathit{dom}(#1)}
\newcommand{\cod}[1]{\mathit{cod}(#1)}
\newcommand{\blame}[1]{\key{blame}\,#1}
\newcommand{\pblame}[2]{\key{blame}\,#1@#2}
\newcommand{\ledyn}{\sqsubseteq}
\newcommand{\IS}{\mathrel{\mathtt{is}}}
\newcommand{\cast}[1]{\overset{#1}{\Rightarrow}}
%\newcommand{\mkcast}[1]{\langle\!\langle#1\rangle\!\rangle}
\newcommand{\mkcast}[1]{(#1)}
\newcommand{\alloc}{\key{ref}\,}
\newcommand{\deref}{\texttt{!}}
\newcommand{\update}{\mathrel{\texttt{:=}}}
\newcommand{\all}[1]{\forall #1.\,}
\newcommand{\ftv}[1]{\mathrm{ftv}(#1)}
\newcommand{\CAST}[1]{\langle #1 \rangle}
\newcommand{\new}[1]{\nu #1.\;}
\newcommand{\case}[3]{\key{case}\,#1\,\key{of}\,\key{inl}\,x\Rightarrow\,#2\,| \,\key{inr}\,x\Rightarrow \,#3}
\newcommand{\join}[2]{#1 \sqcup #2 }
\newcommand{\meet}[2]{#1 \sqcap #2 }
\newcommand{\AND}{\cap}

\newcommand{\EE}[2]{\mathcal{E}\llbracket #1 \rrbracket #2}
\newcommand{\FF}[3]{\mathcal{F}(#1, #2, #3)}
\newcommand{\CC}[1]{\mathcal{C}\llbracket #1 \rrbracket}

\newcommand{\EXP}[1]{\,#1\,}
\newcommand{\CE}[0]{\mathcal{E}}
\newcommand{\SEM}[1]{\llbracket #1 \rrbracket}
\newcommand{\ESEM}[1]{\llbracket #1 \rrbracket}
\newcommand{\TSEM}[1]{\mathcal{T}\llbracket #1 \rrbracket}
\newcommand{\lam}[1]{\lambda #1.\,}
\newcommand{\LAM}[1]{\lambda\!\!\!\lambda #1.\,}
\newcommand{\of}[0]{{:}}
\newcommand{\by}[0]{{:=}}
\newcommand{\INT}[0]{\mathtt{int}}
\newcommand{\REF}[1]{\mathtt{ref}\,#1}
\newcommand{\fix}[1]{\mathtt{fix}\,#1.\,}
\newcommand{\FST}[1]{\mathtt{fst}\, #1}
\newcommand{\SND}[1]{\mathtt{snd}\, #1}
\newcommand{\fst}[1]{\mathsf{fst}(#1)}
\newcommand{\snd}[1]{\mathsf{snd}(#1)}
\newcommand{\emptyenv}[0]{\mathsf{empty}}
\newcommand{\ext}[3]{\mathsf{extend}(#1,#2,#3)}
\newcommand{\tyext}[1]{\mathsf{tyExtend}(#1)}
\newcommand{\lookup}[2]{\mathsf{lookup}(#1,#2)}
\newcommand{\shift}[3]{\,\uparrow^{#1}_{#2}(#3)}
\newcommand{\app}[0]{\;}
\newcommand{\LET}[0]{\mathbf{let}\,}
\newcommand{\IN}[0]{\,\mathbf{in}\,}
\newcommand{\abs}[1]{\mathsf{thunk}(#1)}
\newcommand{\val}[1]{\overline{#1}}
\newcommand{\CASE}[0]{\textsf{case}\,}
\newcommand{\OF}[0]{\,\textsf{of}\,}
%% \newcommand{\IF}[0]{\textbf{if}\,}
%% \newcommand{\THEN}[0]{\,\textbf{then}\,}
%% \newcommand{\ELSE}[0]{\,\textbf{else}\,}
\newcommand{\IF}[0]{\mathsf{ifz}(}
\newcommand{\THEN}[0]{,}
\newcommand{\ELSE}[0]{,}
\newcommand{\FI}[0]{)}
\newcommand{\return}[0]{\mathsf{return}\;}
\newcommand{\bind}[0]{\mathsf{bind}\;}
\newcommand{\down}[0]{\mathsf{down}\;}
\newcommand{\wrong}[0]{\mathsf{wrong}}
\newcommand{\plus}[0]{\mathrel{\mathsf{plus}}}
\newcommand{\zero}[0]{\mathsf{zero}}
\newcommand{\SET}[1]{\mathcal{P}(#1)}
\newcommand{\FSET}[1]{\mathcal{P}_f(#1)}
\newcommand{\store}[0]{\mathsf{store}}
\newcommand{\CHOOSE}[0]{\mathsf{choose}\,}

\newcommand{\WF}[1]{\mathsf{wf}(#1)}
\newcommand{\UP}[1]{\mathord{\uparrow} #1}
\newcommand{\ATOMS}[1]{\mathit{atoms}(#1)}
\newcommand{\sqinter}[0]{\bigsqcap}

\newcommand*\oldmacro{}%
\let\oldmacro\insertshorttitle%
\renewcommand*\insertshorttitle{%
  \oldmacro\hfill%
  \insertframenumber\,/\,\inserttotalframenumber}

\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{footline}[frame number]

%\newtheorem{definition}{Definition}
\newtheorem{conjecture}[theorem]{\translate{Conjecture}}
\newtheorem{proposition}[theorem]{\translate{Proposition}}

\lstdefinestyle{basic}{
%showstringspaces=false,
language=Haskell,
columns=fullflexible,
%basicstyle=\sffamily\small,%
basicstyle=\ttfamily,%
%columns=fixed,
%basewidth=0.49em,
%lineskip=0pt,
%escapechar=@,xleftmargin=1pc,%
%keywordstyle=\ttfamily,
mathescape=true,%
moredelim=**[is][\color{blue}]{@}{@},
moredelim=[is][\color{red}]{|}{|},
moredelim=[is][\color{blue}]{~}{~},
%commentstyle=\rmfamily,%
morekeywords={module,data,where,open},%
deletekeywords={List,const,map,Functor}
}
\lstset{style=basic}

%\garamond

\title{Filter Models for Compiler Correctness}
\author{Jeremy G. Siek \and Matthew Heimerdinger \\[1ex]
 Indiana University, Bloomington
}
\date{}
%% \institute{\normalsize 
%%  Indiana University, Bloomington
%% }

% 1 hou

%\newcommand\footnotemark{}
%\renewcommand\footnoterule{}
\setbeamercolor{footnote mark}{fg=white}

\begin{document}

\frame{

%% \begin{tabular}{ll} 
%\begin{minipage}{0.95\textwidth}
\centering
{\LARGE Filter Models for Compiler Correctness} \\[6ex]
\normalsize Jeremy G. Siek \qquad Matthew Heimerdinger \\
Indiana University\\
Center for Programming Systems \\[2ex]
10th Workshop on Intersection Types and Related Systems \\
17 July 2021
%\end{minipage}
%% &
%% \begin{minipage}{0.45\textwidth}
%% \includegraphics[height=3in]{btf}
%% \end{minipage}
%% \end{tabular}

}
%===============================================================================
\frame{
  \frametitle{Outline}

  \begin{itemize}
  \item Intersections: Type System or Semantics?
  \item Compiling a Functional Language
  \item Challenges and Solutions
    \begin{itemize}
    \item Relations versus Functions
    \item Subtyping and Transitivity
    \item Mechanizing Variables and Substitution
    \item Language-Generic Meta-Theory
    \item Intrinsic Difficulties in Compiler Correctness
    \end{itemize}
  \end{itemize}

}
%===============================================================================
\frame{
\frametitle{Intersections: Type System or Semantics?}

\ \\
A call-by-value $\lambda$-calculus:\\
%\begin{tabular}{cc}
 \fbox{
 \begin{minipage}{0.4\textwidth}
   \footnotesize
\begin{gather*}
  A ::= \top \mid A \AND A \mid A \to A\\[2ex]
%  \inference{}{\Gamma \vdash c : \Delta(c)}\\[1ex]
  \inference{x : A \in \Gamma & A <: B}{\Gamma \vdash x : B} \\[1ex]
  \inference{\Gamma \vdash L : A \to B & \Gamma \vdash M : A}
            {\Gamma \vdash L ~ M : B} \\[1ex]
  \inference{\Gamma, x : A \vdash N : B}
            {\Gamma \vdash \lambda x.N : A \to B} \\[1ex]
  \inference{\Gamma \vdash \lambda x.N : A \quad \Gamma \vdash \lambda x.N : B}
            {\Gamma \vdash \lambda x.N : A \AND B} \\
  \inference{}
            {\Gamma \vdash \lambda x.N : \top}
  %% \inference{\Gamma \vdash M : A & A <: B}
  %%           {\Gamma \vdash M : B}
\end{gather*}
 \end{minipage}}
   $\simeq\,$%
  \fbox{
    \begin{minipage}{0.30\textwidth}
   \footnotesize
    \begin{align*}
   \mathbb{V} \ni u,v,w & ::= \emptyset \mid u \sqcup v \mid v \mapsto w  \\[2ex]
   \SEM{-} &: \mathbb{E} \to (\mathbb{X} \to \mathbb{V}) \to \SET{\mathbb{V}}\\[1ex]
%   \SEM{c}\rho &= \Delta\SEM{c} \\
   \SEM{x}\rho &= \{ v \mid v \sqsubseteq \rho(x) \} \\
   \SEM{L~M}\rho &= \{ w \mid  v\mapsto w \in \SEM{L}\rho,  \\
     & \qquad\quad\;\; v\in \SEM{M}\rho \} \\
   \SEM{\lambda x. N}\rho &= \{ u \mid \forall v {\mapsto} w \in u, \\
   & \qquad\quad\;\; w \in \SEM{N}\rho(x{:=}v)\} 
 \end{align*}
\end{minipage}
}
%\end{tabular}

}
%===============================================================================
\frame{
\frametitle{Basic Properties}

\textbf{Soundness}: If $M \longrightarrow^{*} V$, then $\SEM{M} = \SEM{V}$.\\[1ex]
\textbf{Adequacy}: If $\SEM{M} = \SEM{V}$, then $\exists V, M \longrightarrow^{*} V$.\\[1ex]
\textbf{Equality implies Equivalence}: \\
  $\qquad \SEM{M} = \SEM{N}$ implies $M \overset{\mathrm{ctx}}{=} N$. \\[1ex]
\ \\
\textbf{Not Full Abstraction}: \\
  $\qquad M \overset{\mathrm{ctx}}{=} N$ does not imply $\SEM{M} = \SEM{N}$. \\
\ \\
That's OK, we don't need that direction.

}
%===============================================================================
\frame{
  \frametitle{Compiling a Functional Language}

  \hspace{1in}
  \xymatrix@=20pt{
  \text{ISWIM} \ar[d]^{\quad \text{\normalsize closure conversion}} \ar@(ul,ur)[]^{\quad \text{\normalsize optimize}}\\
  \text{ISWIM$^{\dagger}$} \ar[d]^{\quad \text{\normalsize flatten}} \\
  \text{ANF} \ar[d]^{\quad \text{\normalsize select instructions}} \\
  \text{x86$^{*}$} \ar[d]^{\quad \text{\normalsize register allocation}} \\
  \text{x86}
  }
}
%===============================================================================
\frame{
\frametitle{Closure Conversion}

\large
\begin{align*}
&\LET w = 5, x = 3, y = 3 \IN \\
&\LET f = \lambda z.~ \rd{x} + \rd{y} + z \IN \\
&f \app w \\
& \Downarrow \\
& \mathbf{fun}~ lam\,\rd{v \, z} = \rd{\mathsf{fst}\,v} + \rd{\mathsf{snd}\,v} + z \\
&\LET w = 5, x = 3, y = 3 \IN \\
&\LET f = \rd{\langle lam, \langle x , y \rangle \rangle} \IN \\
&\rd{(\mathsf{fst}\,f) \app (\mathsf{snd}\,f)} \app w
\end{align*}

}
%===============================================================================
\frame{
\frametitle{Optimize: Common Subexpression Elimination}

\Large
\begin{align*}
&  \lam{f} (f \app 5) + (f \app 5) \\
&   \Downarrow \\
&  \lam{f} \LET x = (f \app 5) \IN x + x
\end{align*}

}
%===============================================================================
\frame{
\frametitle{Goal: Correct Compilation}

  \hspace{0.25in}
  \xymatrix@=20pt{
  \SEM{p_1} \ar@{=}[r]& \SEM{p_2}\ar@{=}[d] & \text{$p_1,p_2 \in $ ISWIM} \ar[d]^{\quad \text{\normalsize closure conversion}} \ar@(ul,ur)[]^{\quad \text{\normalsize optimize}}\\
  &\SEM{p_3} \ar@{=}[d] & \text{$p_3 \in $ ISWIM$^{\dagger}$} \ar[d]^{\quad \text{\normalsize flatten}} \\
  &\SEM{p_4} \ar@{=}[d] & \text{$p_4 \in $ ANF} \ar[d]^{\quad \text{\normalsize select instructions}} \\
  &\SEM{p_5} \ar@{=}[d] & \text{$p_5 \in $ x86$^{*}$} \ar[d]^{\quad \text{\normalsize register allocation}} \\
  &\SEM{p_6} & \text{$p_6 \in $ x86}
  }
  
}

%===============================================================================
\frame{
\frametitle{Challenge: relations versus functions}

Common subexpression elimination:
\begin{align*}
&  \lam{f} (f \app 5) + (f \app 5) \\
&   \Downarrow \\
&  \lam{f} \LET x = (f \app 5) \IN x + x
\end{align*}
Unfortunately
\[
\SEM{\lam{f} (f \app 5) + (f \app 5)} \neq \SEM{\lam{f} \LET x = (f \app 5) \IN x + x}
\]
because
\begin{align*} 
  F\mapsto 3  &\in \SEM{\lam{f} (f \app 5) + (f \app 5)} \\
  F\mapsto 3  &\not\in \SEM{\lam{f} \LET x = (f \app 5) \IN x + x}
\end{align*}
where
\[
  \rd{F =  (5\mapsto 1) \sqcup (5\mapsto 2)}
\]

}
%===============================================================================
\frame{
\frametitle{Solution: restrict them to functions}

Recall that if $f$ is a \textbf{function} and
$v \mapsto w \in f$ and $v' \mapsto w' \in f$,
then $v = v'$ implies $w = w'$.

But applying that naively won't rule out:
\begin{align*}
& \; (0 \mapsto 1) \mapsto 2 \\
\sqcup & \; ((0 \mapsto 1) \sqcup (5 \mapsto 6)) \mapsto 3
\end{align*}

We need to generalize the notion of equality to \textbf{consistency}.\\[1ex]
\fbox{$v \sim v$}
\vspace{-10pt}
\begin{gather*}
  \inference{}{c \sim c} \qquad
  \gr{\inference{v \sim v' \text{ implies } w \sim w'}
            {(v \mapsto w) \sim (v' \mapsto w')}} \\[1ex]
  \inference{u_1 \sim v & u_2 \sim v}{(u_1 \sqcup u_2) \sim v} \qquad
  \inference{u \sim v_1 & u \sim v_2}{u \sim (v_1 \sqcup v_2)}
\end{gather*}

}
%===============================================================================
\frame{
\frametitle{Solution: restrict values to be internally consistent}

\begin{gather*}
  \inference{}{\WF{\emptyset}} \quad
  \inference{}{\WF{c}} \quad
  \inference{\WF{v} & \WF{w}}{\WF{v \mapsto w}} \\[2ex]
  \inference{\gr{u \sim v} & \WF{u} & \WF{v} }{\WF{u \sqcup v}}
\end{gather*}

Update the definition of $\SEM{-}$:
\begin{align*}
   \SEM{L~M}\rho &= \{ w \mid \gr{\WF{v}}, v\mapsto w \in \SEM{L}\rho, v\in \SEM{M}\rho \} \\
\end{align*}

}
%===============================================================================
\frame{
\frametitle{Challenge: consistency, ordering, and subformulas}

We want to establish \\[2ex]

\textbf{Theorem} (Determinism)\\ If $v_1 \in \SEM{e}\rho$ and $v_2
\in \SEM{e}\rho$ , then $v_1 \sim v_2$. \\[2ex]

which requires \\[2ex]

\textbf{Lemma} (Consistency is Downward Closed) \\
If $u_1 \sim u_2$, $v_1 \sqsubseteq u_1$, and $v_2 \sqsubseteq u_2$,
then $v_1 \sim v_2$.\\
\ \\
%
but we get stuck on the following case for the transitivity rule of
$\sqsubseteq$ because $v$ may not be well formed, though $u$ and $w$ are.
\[
\inference{u \sqsubseteq \rd{v} & \rd{v} \sqsubseteq w}
          {u \sqsubseteq w}
\]

}
%===============================================================================
\frame{
\frametitle{Value ordering and BCD Subtyping}

The information ordering $u \sqsubseteq v$ is the inverse of BCD
Subtyping: \\[2ex]

\hfill\fbox{$A <: B$}
\begin{gather*}
\inference{}{A <: A} \qquad \rd{\inference{A <: B \quad B <: C}{A <: C}} \quad \inference{}{A <: \top}\\[2ex]
\inference{}{A \AND B <: A} \quad
\inference{}{A \AND B <: B} \quad
\inference{C <: A \quad C <: B}{C <: A \AND B} \\[2ex]
\inference{C <: A \quad B <: D}{A \to B <: C \to D}
\quad
\inference{}{(A\to B) \AND (A \to C) <: A \to (B \AND C)}
\end{gather*}

}
%===============================================================================
\frame{
\frametitle{Solution: Alternative Formulation}

Laurent removes the transitivity rule and turns the $\beta$-soundness
property into a rule in a sequent-style system (ITRS 2018).
\[
   \inference{C \vdash A_1 \cdots C \vdash A_n
         &
         B_1, \ldots, B_n \vdash D}
        {A_1\to B_1,\ldots, A_n\to B_n \vdash C \to D}
\]

But the sequents aren't necessary (Siek 2019). We can instead replace
the standard function subtyping rule with the following.
\[
\inference{C <: \mathsf{dom}(A') & \mathsf{cod}(A') <: D}
          {A <: C \to D}
          {\small \mathsf{graph}(A') \subseteq \mathsf{graph}(A)}
\]
where
\[
  \mathsf{dom}(A \to B) = A, \qquad
  \mathsf{dom}(A \AND B) = \mathsf{dom}(A) \AND \mathsf{dom}(B) 
\]
and similarly for $\mathsf{cod}$.

}
%===============================================================================
\frame{
\frametitle{Properties of the Filter Model}

\begin{itemize}
\item (Weakening) If $\rho_1 \sqsubseteq \rho_2$, then $\SEM{M}\rho_1 \subseteq
  \SEM{M}\rho_2$.
\item (Subsumption) If $v \in \SEM{M}\rho$ and $w \sqsubseteq v$,
  then $w \in \SEM{M}\rho$.
\item (Determinism) If $v_1 \in \SEM{M}\rho$ and $v_2 \in \SEM{M}\rho$, then $v_1
  \sim v_2$.
\item ($\sqcup$-Intro.)
  If $v_1 \in \SEM{M}\rho$ and $v_2 \in \SEM{M}\rho$, then $v_1
  \sqcup v_2 \in \SEM{M}\rho$.
\end{itemize}


}
%===============================================================================
\frame{
\frametitle{Solution: Another Formulation of Subtypign}

Huang, Zhao, and Oliveira (2021) \\[1ex]

Splitting \fbox{$B \triangleleft A \triangleright C$}
\[
\inference{}{A \triangleleft (A \AND B) \triangleright B}
\qquad
\inference{C \triangleleft B \triangleright D}
          {(A \to C) \triangleleft (A \to B) \triangleright (A \to D)}
\]

Unsplittable (aka. Ordinary)
\[
   \overline{A} ::= \top \mid A \to \overline{A}
\]

Subtyping
\begin{gather*}
  \inference{}{A <: \top}
  \quad
  \inference{A <: B & A <: C}            
            {A <: D} \small{B \triangleleft D \triangleright C} \\[2ex]
   \quad
  \inference{A <: \overline{C}}  
            {A \AND B <: \overline{C}}
  \quad
  \inference{B <: \overline{C}}
            {A \AND B <: \overline{C}}
  \quad
  \inference{B <: A & C <: \overline{D}}
            {A \to C <: B \to \overline{D}}
\end{gather*}
}  
%===============================================================================
\frame{
\frametitle{Challenge: Mechanizing Variables and Substitution}

Since the POPLmark challenge in 2005, researchers have explored many
approaches: \\[2ex]

\begin{itemize}
\item names
\item de Bruijn indices
\item locally nameless
\item nominal logic
\item higher-order abstract syntax
\item parameterized higher-order abstract syntax
\end{itemize}

}
%===============================================================================
\frame[containsverbatim]{
\frametitle{Solution: McBride's approach to de Bruijn indices}

\begin{lstlisting}
(a $\bullet$ f) 0 = a         $\hspace{1.5in}\rho : \mathbb{N} \to \mathbb{N}$
(a $\bullet$ f) (suc n) = f n $\hspace{0.8in}\sigma : \mathbb{N} \to \mathbb{E}$
  
$\Uparrow$ $\rho$ x = suc ($\rho$ x)
  
rename $\rho$ x = $\rho$ x
rename $\rho$ ($\lambda$ N) = $\lambda$ (rename (0 $\bullet$ $\Uparrow \rho$) N)
rename $\rho$ (L $\cdot$ M) = (rename $\rho$ L) $\cdot$ (rename $\rho$ M)

$\Uparrow$ $\sigma$ x = rename suc ($\sigma$ x)

subst $\sigma$ x =  $\sigma$ x
subst $\sigma$ ($\lambda$ N) = $\lambda$ (subst (0 $\bullet$ $\Uparrow \sigma$) N)
subst $\sigma$ (L $\cdot$ M) =  (subst $\sigma$ L) $\cdot$ (subst $\sigma$ M)
\end{lstlisting}

}
%===============================================================================
\frame{
  \frametitle{Challenge: Repetative Meta-theory!}

  We need to prove properties about all of these languages: \\
  \ \\ 
  
  \hspace{1in}
  \xymatrix@=20pt{
  \text{ISWIM} \ar[d]^{\quad \text{\normalsize closure conversion}} \ar@(ul,ur)[]^{\quad \text{\normalsize optimize}}\\
  \text{ISWIM$^{\dagger}$} \ar[d]^{\quad \text{\normalsize flatten}} \\
  \text{ANF} \ar[d]^{\quad \text{\normalsize select instructions}} \\
  \text{x86$^{*}$} \ar[d]^{\quad \text{\normalsize register allocation}} \\
  \text{x86}
  }
  
}
%===============================================================================
\frame[containsverbatim]{
  \frametitle{Solution: Abstract Binding Trees}

  Adapt Harper's abstraction binding trees to Agda.\\
  A generic AST that knows about variable binding and
  is parameterized on the operators and their number of bindings.
  
  \begin{lstlisting}[basicstyle=\small]
  module AbstractBindingTree (Op : Set) (sig: Op $\to$ List $\mathbb{N}$) where
    data ABT : Set where
      var : $\mathbb{N}$ $\to$ ABT
      apply : (op : Op) $\to$ Args (sig op) $\to$ ABT

    data Args where
      nil : Args []
      cons : $\forall${b bs} $\to$ Arg b $\to$ Args bs $\to$ Args (b :: bs)  

    data Arg : $\mathbb{N}$ $\to$ Set where
      ast : ABT $\to$ Arg 0
      bind : $\forall${b} $\to$ Arg b $\to$ Arg (suc b)
  \end{lstlisting}

}
%===============================================================================
\frame[containsverbatim]{
  \frametitle{Example ABT for ISWIM}

  \begin{lstlisting}[basicstyle=\small]
  data LambdaOp : Set where
    lam : LambdaOp
    app : LambdaOp
    lit : (p : Prim) $\to$ rep p $\to$ LambdaOp

  lambdaSig : LambdaOp $\to$ List $\mathbb{N}$
  lambdaSig lam = 1 :: []
  lambdaSig app = 0 :: 0 :: []
  lambdaSig (lit p k) = []

  open import AbstractBindingTree LambdaOp lambdaSig
  
  pattern $\lambda$ N = apply lam (cons (bind (ast N)) nil)
  pattern _$\cdot$_ L M = apply app (cons (ast L) (cons (ast M) nil))
  pattern const p k = apply (lit p k) nil
  \end{lstlisting}

  
}
%===============================================================================
\frame{
  \frametitle{Generic Theorems about ABT's}

\textbf{Theorem} (Substitution Commutes with Itself)\ \\
  For any ABT's $M,L,N$ of the same \textsf{Op} and \textsf{sig},
\begin{gather*}
  M[ x:= N ][ y := L ] = M[ y:= L][ x := N[y := L] ] \qquad \text{if }x \neq y
%  \sigma (M[x := N]) = \sigma(M)[x := \sigma(N)] \qquad \text{if } x \notin \mathrm{dom}(\sigma)
\end{gather*}

\ \\

\textbf{Theorem} (Substitution Commutes with Semantics) \\
%
For any semantics $\SEM{-}$, environment $\rho$, and ABT $M$,
\[
\SEM{M[x := N]} \rho = \SEM{M} \rho(x := \SEM{N}\rho)
\]

\footnote{Inspired by Allais, Atkey, Chapman, McBride, McKinna (ICFP 2018).}

}
%===============================================================================
\frame{
\frametitle{Graph Models vs. Filter Models}

Graph Model:
\[
\SEM{-} : \mathbb{E} \to (\mathbb{X} \to \rd{\SET{\mathbb{V}}}) \to \SET{\mathbb{V}}
\]
\[
\SEM{M[x := N]} \rho = \SEM{M} \rho(x := \SEM{N}\rho)
\]

Filter Model:
\[
\SEM{-} : \mathbb{E} \to (\mathbb{X} \to \rd{\mathbb{V}}) \to \SET{\mathbb{V}}
\]
\[
\SEM{M[x := N]} \rho = \bigcup_{v \in \SEM{N}\rho} \SEM{M} \rho(x := v)
\]

We've been using filter models, but the graph models seem to be a
better fit for the generic theorems about ABTs.

}
%===============================================================================
\frame{
  \frametitle{Graph Models vs. Filter Models}
\begin{center}
  Comparison of the semantic functions
\end{center}
 \fbox{
 \begin{minipage}{0.40\textwidth}
   \footnotesize
    \begin{align*}
   \SEM{-} &: \mathbb{E} \to (\mathbb{X} \to \rd{\SET{\mathbb{V}}}) \to \SET{\mathbb{V}}\\[1ex]
   \SEM{x}\rho &= \rd{\rho(x)} \\
   \SEM{L~M}\rho &= \{ w \mid  v\mapsto w \in \SEM{L}\rho,  \\
     & \qquad\quad\;\; v\in \SEM{M}\rho \} \\
   \SEM{\lambda x. N}\rho &= \{ w \mid \forall u {\mapsto} v \in \mathsf{graph}(w), \\
   & \qquad\quad\;\; v \in \SEM{N}\rho(x{:=}\rd{\downarrow u})\} 
 \end{align*}
 \end{minipage}}
%
  \fbox{
    \begin{minipage}{0.40\textwidth}
   \footnotesize
    \begin{align*}
   \SEM{-} &: \mathbb{E} \to (\mathbb{X} \to \rd{\mathbb{V}}) \to \SET{\mathbb{V}}\\[1ex]
   \SEM{x}\rho &= \rd{\downarrow \rho(x)} \\
   \SEM{L~M}\rho &= \{ w \mid  v\mapsto w \in \SEM{L}\rho,  \\
     & \qquad\quad\;\; v\in \SEM{M}\rho \} \\
   \SEM{\lambda x. N}\rho &= \{ w \mid \forall u {\mapsto} v \in \mathsf{graph}(w), \\
   & \qquad\quad\;\; v \in \SEM{N}\rho(x{:=}\rd{u})\} 
 \end{align*}
\end{minipage}}
\\[2ex]
where
\[
\downarrow u = \{ v \mid v \sqsubseteq u \}
\]

}
%===============================================================================
\frame[containsverbatim]{
\frametitle{Graph Model: Application (F) and Abstraction (G)}

\footnotesize
\begin{align*}
  \SEM{x}\rho &= \rho(x) \\
  \SEM{L~M}\rho &= \gr{\{ w \mid  v\mapsto w \in \rd{\SEM{L}\rho}, v\in \rd{\SEM{M}\rho} \}} \\
  \SEM{\lambda x. N}\rho &= \gr{\{ w \mid \forall u {\mapsto} v \in \mathsf{graph}(w), v \in \rd{\SEM{N}\rho(x{:=}\gr{\downarrow u})}\} }
\end{align*}

\begin{align*}
  \gr{F} &: \mathcal{P}(\mathbb{V}) \to (\mathcal{P}(\mathbb{V}) \to \mathcal{P}(\mathbb{V})) \\
  \gr{F}\app \rd{d_1} \app \rd{d_2} &= \gr{\{ w \mid  v\mapsto w \in \rd{d_1}, v\in \rd{d_2} \}} \\[2ex]
  \gr{G} &: (\mathcal{P}(\mathbb{V}) \to \mathcal{P}(\mathbb{V})) \to \mathcal{P}(\mathbb{V})\\
  \gr{G} \app \rd{f} & = \gr{\{ w \mid \forall u \mapsto v \in \mathsf{graph}(w), v \in \rd{f}(\downarrow u) \} }
\end{align*}

\begin{align*}
  \SEM{x}\rho &= \rho(x) \\
  \SEM{L~M}\rho &= \gr{F} \app \SEM{L}\rho \app \SEM{M}\rho \\
  \SEM{\lambda x. N}\rho &= \gr{G} \app (\lambda d. \SEM{N}\rho(x{:=}d))
\end{align*}

}

%===============================================================================
\frame[containsverbatim]{
\frametitle{Maps and Folds on ABTs}

\begin{lstlisting}[basicstyle=\small]
map : $\forall$ V. ($\mathbb{X}$ $\to$ V) $\to$ ABT $\to$ ABT
   ($V$ is equiped with $\lceil - \rceil$ : V $\to$ ABT)
rename = map $\mathbb{N}$
subst = map ABT

fold : $\forall$ V. Func V $\to$ V $\to$ ($\mathbb{X} \to V$) $\to$ ABT $\to$ V
  where
  Func V = (op : Op) $\to$ Tuple (sig op) (ArgTy V) $\to$ V
  
  ArgTy V 0 = V
  ArgTy V (suc n) = V $\to$ ArgTy V n

sem : Func $\mathcal{P}(\mathbb{V})$
sem app = $\gr{F}$
sem lam = $\gr{G}$
$\SEM{M}\rho$ = fold sem $\emptyset$ $\rho$ $M$
\end{lstlisting}
 
}
%===============================================================================
\frame[containsverbatim]{
\frametitle{Properties of Maps and Folds}

map-map fusion:
\[
\mathtt{map}\app f_2\app (\mathtt{map}\app f_1\app M)
 = \mathtt{map} \app (f_2 \circ f_1) \app M
\]

fold-map fusion:
\[
\mathtt{fold} \app f_2 \app d \app \delta \app (\mathsf{map} \app f_1\app M)
= \mathtt{fold} \app f_2 \app d \app
   (\lambda x. \mathtt{fold}\app f_2\app d\app \delta\app \lceil f_1 \app x \rceil)) \app M
\]

}
%===============================================================================
\frame{
\frametitle{Challenge: Intrinsic Difficulties}

We factor closure conversion into the following steps: \\[2ex]

\hspace{0.5in}
\begin{minipage}{0.25\textwidth}
\xymatrix@=20pt{
  \text{ISWIM} \ar[d]^{\quad \text{\normalsize enclose}} \\
  \text{ISWIM$_1$} \ar[d]^{\quad \text{\normalsize compress}} \\
  \text{ISWIM$_2$} \ar[d]^{\quad \text{\normalsize \rd{delay}}} \\
  \text{ISWIM$_3$} \ar[d]^{\quad \text{\normalsize concretize}} \\
  \text{ISWIM$_4$} \ar[d]^{\quad \text{\normalsize hoist}} \\
  \text{ISWIM$^\dagger$}
}
\end{minipage}
\hspace{0.1in}
\begin{minipage}{0.5\textwidth}
  delay:
\begin{align*}
&\LET w = 5, x = 3, y = 3 \IN \\
&\LET f = (\lambda^{\rd{x y}} z.~ x + y + z) \IN \\
&f \app w \\
& \Downarrow \\
&\LET w = 5, x = 3, y = 3 \IN \\
&\LET f = \rd{\langle} (\lambda x y, z.~ x + y + z), \langle x , y \rangle \rd{\rangle} \IN \\
&(\mathsf{fst}\app f) \rd{@} (\mathsf{snd}\app f) \app w
\end{align*}

Our proof of correctness using \\
logical relations is still in progress.
\end{minipage}

}
%===============================================================================
\frame{
  \frametitle{Conclusion}

  \begin{itemize}
  \item Intersection types make for a denotational semantics
    that is relatively easy to mechanize.
  \item Compilation correctness is a challenging application. We've
    made progress but still have a ways to go.
  \item Generic syntax and meta-theory is helping us manage the
    complexity.
  \end{itemize}

}
%===============================================================================

\end{document}

\frame{
\frametitle{Tabulating Functions}

Syntax of an applied lambda calculus:
\[
  \begin{array}{rcl}
  && n \in \mathbb{Z} \qquad x \in \mathbb{X} \;\;\text{(program variables)}\\
  e \in \mathbb{E} & ::= & x \mid \lam{x} e \mid e \; e \mid \\
  & & n \mid e \oplus e \mid \IF e \THEN e \ELSE e  \FI\\
  v & ::= & n \mid \lam{x} e \\
  \oplus & ::= & + \mid - \mid \times 
  \end{array}
\]

Denotations:
\begin{center}
  \fbox{\fbox{
      $
      \begin{array}{ll}
      d ::= n \mid \{ d_1{\mapsto} d'_1,\ldots, d_n{\mapsto} d'_n \}\\[1ex]
      \mathbb{D} = \mathbb{Z} + \mathcal{P}_{f}(\mathbb{D} \times \mathbb{D})
      \end{array}
      $
}}
\end{center}

Let $t$, for table, range over $\mathcal{P}_{f}(\mathbb{D} \times \mathbb{D}) $.

}

%===============================================================================
\frame{
\frametitle{A Compositional Big-Step Semantics}
\small
\vspace{5pt}
\hfill\fbox{$\rho \vdash e \Rightarrow d$}
\begin{gather*}
  \inference
      { d \sqsubseteq \rho(x)}
      {\rho \vdash x \Rightarrow d}
  \;
  \inference
      {\forall\, d{\mapsto}d'\in t,\\ \rho(x{:=}d) \vdash e \Rightarrow d'}
      {\rho \vdash \lam{x}e \Rightarrow t}
  \;
  \inference
      {\rho \vdash e_1 \Rightarrow t &
       \rho \vdash e_2 \Rightarrow d_2 \\
      d \mapsto d' \in t & d \sqsubseteq d_2 & d_3 \sqsubseteq d'}
      {\rho \vdash (e_1\app e_2) \Rightarrow d_3}
  \\[2ex]
  \inference{}{\rho \vdash n \Rightarrow n}
  \qquad
  \inference
      {\rho \vdash e_1 \Rightarrow n_1 &
       \rho \vdash e_2 \Rightarrow n_2}
      {\rho \vdash e_1 \oplus e_2 \Rightarrow n_1 \oplus n_2}
  \\[2ex]
  \inference{\rho \vdash e_1 \Rightarrow 0 & 
    \rho \vdash e_2 \Rightarrow d}
            {\rho \vdash \IF e_1 \THEN e_2 \ELSE e_3 \FI \Rightarrow d}
  \;
  \inference{\rho \vdash e_1 \Rightarrow n & n \neq 0 &
    \rho \vdash e_3 \Rightarrow d}
            {\rho \vdash \IF e_1 \THEN e_2 \ELSE e_3 \FI \Rightarrow d}
\end{gather*}
\hrule
\hrule
\vspace{5pt}
Comparison to a standard big-step semantics:
\begin{gather*}
  \inference{}
            {\varrho \vdash \lam{x} e \Rightarrow \langle \lam{x}e,\varrho \rangle}
  \qquad
  \inference{\varrho \vdash e_1 \Rightarrow \langle \lam{x}e,\varrho' \rangle&
             \varrho \vdash e_1 \Rightarrow v_2 \\
             \varrho'(x\by v_2) \vdash e \Rightarrow v}
            {\varrho \vdash (e_1 \app e_2) \Rightarrow v}
\end{gather*}
}
%===============================================================================
\frame{
\frametitle{The Semantics in Denotational Form}

Of course, relations are isomorphic to set-valued functions:
\[
  \SET{(\mathbb{X} \to \mathbb{D}) \times \mathbb{E} \times \mathbb{D}}
  \quad\cong\quad
  \mathbb{E} \to (\mathbb{X} \to \mathbb{D}) \to \SET{\mathbb{D}}
\]

}

%===============================================================================

\frame{
\frametitle{The Semantics in Denotational Form}

\fbox{$\SEM{-}: \mathbb{E} \to (\mathbb{X} \to \mathbb{D}) \to \SET{\mathbb{D}}$}
\begin{align*}
\SEM{ n }\rho &= \{ n \} \\
\SEM{ e_1 \oplus e_2 }\rho &= \{  n_1 \oplus n_2 \mid 
   n_1 \in \SEM{ e_1 }\rho \text{ and } n_2 \in \SEM{ e_2 }\rho \} \\
\SEM{ x }\rho &= \{ d \mid d \sqsubseteq \rho(x) \} \\
\SEM{ \lam{x} e }\rho &= 
  \{ t \mid \forall d\mapsto d'\in t,\, d' \in \SEM{ e }\rho(x{:=}d) \} \\
\SEM{ e_1\;e_2 }\rho &= \left\{ d_3 \, \middle| 
   \begin{array}{l}
   \exists t\, d_2\, d\, d'.\, t \in \SEM{ e_1 }\rho,\, d_2 \in \SEM{ e_2 }\rho, \\
   d\mapsto d' \in t, \, d \sqsubseteq d_2,\, d_3 \sqsubseteq d'
   \end{array}
\right\} \\
\SEM{\IF e_1 \THEN e_2 \ELSE e_3 \FI}\rho &=
\left\{ d\, \middle|\,
  \begin{array}{l}
   \exists n.\, n \in \SEM{e_1}\rho, \\
   \quad (n= 0 \implies d \in \SEM{e_2}\rho) \text{ and}\\
   \quad (n\neq 0 \implies d \in \SEM{e_3}\rho)
  \end{array}
  \right\}
\end{align*}

}

%===============================================================================
\frame{
\frametitle{$\beta_v$-reduction}

\textbf{Theorem} (Equality of $\beta_v$-reduction)
\[
\SEM{(\lam{x}e) \app v} = \SEM{e[v/x]}
\]

One direction of the proof relies on \\[2ex]

\textbf{Lemma}  (Reverse Substitution)\\
  If $d \in \SEM{e[v/x]}$ then
  $\exists d' \in \SEM{v}\emptyset,\; d \in \SEM{e}\rho(x{:=}d')$.\\[2ex]

which in turn relies on \\[2ex]

\textbf{Lemma} (Combine Denotations of Values)\\
If $d_1 \in \SEM{v}\rho$ and $d_2 \in \SEM{v}\rho$,
then $d_1 \sqcup d_2 \in \SEM{v}\rho$.


}

%===============================================================================

\frame{
\frametitle{Goal: arbitrary $\beta$-reduction}

To justify optimizing via function inlining, we'd like:\\[2ex]

\textbf{Theorem} (Equality of $\beta$-reduction for CBV)\\
\[
\SEM{(\lam{x}e) \app e'} = \SEM{e[e'/x]}
\qquad \text{if } \SEM{e'} \neq \emptyset
\]
\vspace{5pt}

This requires\\[2ex]

\textbf{Lemma} (Combine Denotations of Expressions)\\
If $d_1 \in \SEM{e}\rho$ and $d_2 \in \SEM{e}\rho$,
then $d_1 \sqcup d_2 \in \SEM{e}\rho$.

}

%===============================================================================
\frame{
   \frametitle{Tables are Relations, not Functions}

A problem with the lambda's-as-tables approach:
\begin{align*}
  \lam{f} (f \app 5) + (f \app 5)
  & \stackrel{\mathrm{ctx}}{=}
  \lam{f} (\lam{x} x + x) \app (f \app 5)
\\
  \ESEM{\lam{f} (f \app 5) + (f \app 5)}
  &\neq
  \ESEM{\lam{f} (\lam{x} x + x) \app (f \app 5)}
\end{align*}

Why not equal?
\begin{align*}
  R &= \{ 5\mapsto 1, 5\mapsto 2 \}\\
  \{ R\mapsto 3 \} &\in \ESEM{\lam{f} (f \app 5) + (f \app 5)} \\
  \{ R\mapsto 3 \} &\not\in \ESEM{\lam{f} (\lam{x} x + x) \app (f \app 5)} 
\end{align*}
   
This is bad, we need this equality to justify a standard compiler
optimization: common subexpression elimination!

}
%===============================================================================
\frame{
  \frametitle{Restrict the tables to be functions}

  \begin{itemize}
    \item Recall the definition: a \textbf{function} $f$ is a relation
      such that\\
      if $(a,b) \in f$ and $(a,b') \in f$, then $b = b'$.
    \item Can we add this restriction to the denotations?
    \item Not quite, it would allow bogus tables such as
      \[
      \{ \{0{\mapsto} 1\} \mapsto 2, \{0{\mapsto} 1, 5{\mapsto} 6 \} \mapsto 3 \}
      \]   
  \end{itemize}

  We need a generalization of equality that makes sense for
  approximations of functions.
  
\begin{gather*}
  \frac{}{n \sim n}
  \qquad
  \frac{\begin{array}{l}\forall d_1 d'_1 d_2 d'_2, d_1{\mapsto} d'_1 \in t_1 \land d_2 {\mapsto} d'_2 \in t_2 \\
        \implies (d_1 \sim d_2 \land d'_1 \sim d'_2) \lor d_1 \not\sim d_2
        \end{array}}
    {t_1 \sim t_2}
\end{gather*}

}
%===============================================================================
\frame{
  \frametitle{Determinism}

  With this restriction, I was able to prove the following in December
  of 2017. \\[2ex]

  \textbf{Theorem} (Determinism)\\ If $d_1 \in \SEM{e}\rho$ and $d_2
  \in \SEM{e}\rho$ , then $d_1 \sim d_2$. \\[2ex]

  In general for partial orders, one often has
  \[
    a \sim b \text{ iff } \exists c,\; c = a \sqcup b
  \]
  So I thought that the lemma Combine Denotations of Expressions would
  easily follow. \\[2ex]

  It didn't.
}
%===============================================================================
\frame{
  \frametitle{Challenge \#1}


  I had been using the follow definition of $\sqsubseteq$
  \[
    \inference{}{n \sqsubseteq n}
    \qquad
    \inference{t_1 \subseteq t_2}
               {t_1 \sqsubseteq t_2}
  \]
  which leads to this definition of $\sqcup$:
  \begin{align*}
    n \sqcup n &= n \\
    t_1 \sqcup t_2 &= t_1 \cup t_2
  \end{align*}
    
}

%===============================================================================

\frame{
  \frametitle{Challenge \#1}
  
Let's try to prove Combine Denotations of Expression by induction on
$e$. Consider the case for application: $e = (e_1 \app e_2)$. From $v
\in \ESEM{e_1 \app e_2}\rho$ and $v' \in \ESEM{e_1 \app e_2}\rho'$ we
need to show $v \sqcup v' \in \ESEM{e_1 \app e_2}$.
We have something like
\begin{gather*}
t \in \ESEM{e_1}\rho \qquad v_2 \in \ESEM{e_2}\rho \qquad
  v_2 \mapsto v \in t \\
t' \in \ESEM{e_2}\rho' \qquad v'_2 \in \ESEM{e_2}\rho' \qquad
  v'_2 \mapsto v' \in t
\end{gather*}
By the induction hypothesis we have
\[
t \sqcup t' \in \ESEM{e_1} \qquad
v_2 \sqcup v'_2 \in \ESEM{e_2}
\]
We need to show that 
\[
   (v_2 \sqcup v'_2) \mapsto (v \sqcup v') \in t \sqcup t' 
\]
But we cannot. Set union does not mix together information from
entries in $t$ and $t'$ to form new entries.

}

%===============================================================================

\frame{
  \frametitle{Solution \#1: Intersection Types to the rescue!}

  \begin{itemize}
  \item Our denotations $\mathbb{D}$ and ordering $\sqsubseteq$ can be
    viewed as a simple form of intersection types and subtyping.
  \item Barendregt-Coppo-Dezani (BCD) subtyping solves challenge \#1
    with the following rules:
    \begin{gather*}
      \inference{}{(A\to B) \sqcap (A \to C) <: A \to (B \sqcap C)}\\[2ex]
      \inference{C <: A \quad B <: D}{A \to B <: C \to D}
    \end{gather*}
  \end{itemize}

}

%===============================================================================
\frame{
  \frametitle{Challenge \#2: Consistency and Subtyping}

The following was easy to prove with $\mathbb{D}$ and ordering
$\sqsubseteq$. \\
But with intersection types, not so much.\\[2ex]
  
\textbf{Lemma} (Consistency and Subtyping)
\begin{itemize}
\item  If $A \sim B$, $A <: C$, and $B <: D$,
  then $C \sim D$.
\item If $A \not\sim B$, $C <: A$, $D <: B$, then $C \not\sim D$.
\end{itemize}
\vspace{5pt}

I got stuck on the cases for subtyping via the transitivity rule.

}
%===============================================================================
\frame{
  \frametitle{BCD Subtyping}

  \hfill\fbox{$A <: B$}
\begin{gather*}
\inference{}{A <: A} \qquad \inference{A <: B \quad B <: C}{A <: C} \\[2ex]
\inference{}{A \sqcap B <: A} \quad
\inference{}{A \sqcap B <: B} \quad
\inference{C <: A \quad C <: B}{C <: A \sqcap B} \\[2ex]
\inference{C <: A \quad B <: D}{A \to B <: C \to D}
\quad
\inference{}{(A\to B) \sqcap (A \to C) <: A \to (B \sqcap C)}
\end{gather*}

\vspace{10pt}

\begin{center}
  Fails the sub-formula property because of the transitivity rule.
\end{center}

}

%===============================================================================
\frame{
  \frametitle{Solution \#2: Olivier Laurent to the rescue!}

In \textit{Intersection Types with Subtyping by Means of Cut
  Elimination} (Fund. Inf. 2012), Olivier Laurent defines subtyping
without transitivity and instead proves it, but it does not satisfy
the sub-formula property because of an additional rule. Olivier admits
\begin{quote}
``it would be much nicer and much more natural to go through a
  sub-formula property''
\end{quote}

So I emailed Olivier in June and go the reply
\begin{quote}
``Indeed! I now have two different sequent-calculus systems which are
  equivalent to BCD subtyping and satisfy the sub-formula property.  I
  am currently writing a paper on this but it is not ready yet.''
\end{quote}

}
%===============================================================================
\frame{
  \frametitle{Olivier's Definition of Subtyping}
  
  $A_1,\ldots,A_n \vdash B$
   means 
  $A_1 \sqcap \cdots \sqcap A_n <: B$.

  Let $\Sigma$ be a sequence of types.

  \vspace{10pt}
  \hfill\fbox{$\Sigma \vdash A$}
\begin{gather*}
  \inference{\Sigma_1, \Sigma_2 \vdash A}
       {\Sigma_1 , n, \Sigma_2 \vdash A} \qquad
  \inference{\Sigma_1, \Sigma_2 \vdash A}
       {\Sigma_1 , B \to C, \Sigma_2 \vdash A}
   \\[2ex]
   \inference{\Sigma \vdash A \quad \Sigma \vdash B}{\Sigma \vdash A \sqcap B}
   \qquad
   \inference{\Sigma_1,B,C,\Sigma_2 \vdash A}{\Sigma_1,B\sqcap C,\Sigma_2 \vdash A}
   \\[2ex]
   \inference{}{n \vdash n}
   \qquad
   \inference{A \vdash C_1 \cdots A \vdash C_n
         &
         D_1, \ldots, D_n \vdash B}
        {C_1\to D_1,\ldots, C_n\to D_n \vdash A \to B}
\end{gather*}

\begin{center}
Simple, elegant, beautiful!
\end{center}

}

%===============================================================================
\frame{
  \frametitle{Olivier's Road to Transitivity}

\noindent \textbf{Lemma} (Weakening)\\
  If $\Sigma_1,\Sigma_2 \vdash A$,
  then $\Sigma_1,B,\Sigma_2 \vdash A$. \\[1ex]

\noindent \textbf{Lemma} (Axiom)\\
$A \vdash A$ \\[1ex]

\noindent \textbf{Lemma} (Permutation)\\
  If $\Sigma_1 \vdash A$ and $\Sigma_2$ is a permutation of $\Sigma_1$,
  then $\Sigma_2 \vdash A$. \\[1ex]
  
\noindent \textbf{Lemma} ($\sqcap L_e$) \\
If $\Sigma_1,A\sqcap B,\Sigma_2 \vdash C$, then
$\Sigma_1,A, B,\Sigma_2 \vdash C$. \\[1ex]

\noindent \textbf{Lemma} (Collapse Duplicates) \\
%
If $\Sigma_1,A,A,\Sigma_2 \vdash C$, then $\Sigma_1,A,\Sigma_2 \vdash
C$. \\[1ex]

\noindent \textbf{Theorem} (Cut Elimination)\\
  If $\Sigma_2 \vdash B$ and $\Sigma_1,B,\Sigma_3 \vdash C$,
  then $\Sigma_1,\Sigma_2,\Sigma_3 \vdash C$. 
  
}  
%===============================================================================
\frame{
  \frametitle{The Usual Properties of Subtyping }

  \[
    A <: B  \text{ iff } A \vdash B
  \]
  
\textbf{Proposition} (Properties of Subtyping) 
\begin{itemize}
\item $A <: A$.
\item If $A <: B$ and $B <: C$, then $A <: C$. 
\item If $C <: A$ and $B <: D$, then $A \to B <: C \to D$.
\item If $A_1 <: B$, then $A_1 \sqcap A_2 <: B$.
\item If $A_2 <: B$, then $A_1 \sqcap A_2 <: B$.
\item If $B <: A_1$ and $B <: A_2$, then $B <: A_1 \sqcap A_2$.
\item If $A <: C$ and $B <: D$, then $A \sqcap B <: C \sqcap D$.
\item $(A\to B) \sqcap (A \to C) <: A \to (B \sqcap C)$.
\item $(A \to C) \sqcap (B \to D) <: (A\sqcap B) \to (C \sqcap D)$
\end{itemize}

}
%===============================================================================
\frame{
  \frametitle{Back to Consistency and Subtyping}

Definition of \textit{atoms}.
\begin{gather*}
  \ATOMS{n} = \{ n \} \qquad
  \ATOMS{A\to B} = \{ A \to B \} \\
  \ATOMS{A \sqcap B} = \ATOMS{A} \cup \ATOMS{B}
\end{gather*}

\textbf{Lemma} (Atomic Consistency) \\
$A \sim B$ iff (for all $C \in \ATOMS{A}$ and $D \in \ATOMS{B}$, $C
\sim D$).\\[1ex]

\noindent \textbf{Lemma} (Atomic Subtyping)\\
...\\[1ex]

\noindent \textbf{Lemma} (Subtyping Inversion for Function Types)\\
%
If $C <: A \to B$, then ... \\[1ex]

\noindent \textbf{Lemma} (Consistency and Subtyping)\\
  If $A \sim B$, $A <: C$, and $B <: D$,
  then $C \sim D$.
  
}
%===============================================================================
\frame{
\frametitle{Back to Combining Denotations of Expressions}

Definition of well-formed type.
\begin{gather*}
  \frac{}{\WF{n}}
  \qquad
  \frac{\WF{A} \quad \WF{B}}{\WF{A \to B}}
  \qquad
  \frac{A \sim B \quad \WF{A} \quad \WF{B}}{\WF{A \sqcap B}}
\end{gather*}

\noindent \textbf{Lemma} (Weakening)\\
If $A \in \ESEM{e}\Gamma_1$ and $\Gamma_2 <: \Gamma_1$,
then $A \in \ESEM{e}\Gamma_2$. \\[2ex]

\noindent \textbf{Lemma} (Combining Denotations of Expressions)\\
If $A_1 \in \ESEM{e}\Gamma_1$, $A_2 \in \ESEM{e}\Gamma_2$,
$\WF{\Gamma_1}$, $\WF{\Gamma_2}$,
and $\Gamma_1 \sim \Gamma_2$, \\
then $A_1 \sqcap A_2 \in \ESEM{e}(\Gamma_1\sqcap\Gamma_2)$ and
  $\WF{A_1 \sqcap A_2}$.\\[2ex]

The following can then also be proved.\\[2ex]

\noindent \textbf{Proposition} (Subsumption)\\
If $A \in \ESEM{e}\Gamma$, $A <: B$, $\WF{B}$, $\WF{\Gamma}$,
then $B \in \ESEM{e}\Gamma$. 

}

%===============================================================================

\frame{
  \frametitle{Conclusions}

  \begin{itemize}
  \item Restricting the tables to be functions gives us
    determinism, common subexpression elimination, and
    $\beta$-equality (function inlining)!
    
  \item Subtyping for intersections types: Olivier's elegant
    formulation satisfies the sub-formula property!
    
  \end{itemize}
}

\end{document}

% LocalWords:  titlepage containsverbatim frametitle  Siek Taha lstlisting
% LocalWords:  Rightarrow IU CBV Denotational SECD Landin Plotkin et
% LocalWords:  texttt Rightarrow texttt texttt Rightarrow Findler deriv Wadler
% LocalWords:  Longrightarrow Longrightarrow circ Wrigstad ldots inc bytecode
% LocalWords:  includegraphics invokedynamic switchpoints unboxed xymatrix rrr
% LocalWords:  vspace newsavebox DistExample lrbox linewidth mathtt mathtt emph
% LocalWords:  vdash usebox mathbf mathit longmapsto mathsf subtyping emptyset
% LocalWords:  Henglein's footnotesize Drossopoulou Igarashi Gronski Dimoulas
% LocalWords:  varphi eval Jython microbenchmarks Fibonnaci vitousek bharadwaj
% LocalWords:  Shashank  Barendregt al Coppo Dezani Salle Damas Rees
%%  LocalWords:  Felleisen Compositional denotational rcl de Atkey AO
%%  LocalWords:  lcl lccl Heh subsumption wrt Abramsky's btw BCDC BCD
%%  LocalWords:  CDCHL Abramsky BDS iff Inhabitation CDHL HL Bool FV
%%  LocalWords:  darkgreen Egidi Honsell Ronchi Rocca preorder Alessi
%%  LocalWords:  Barbanera Ciancaglini nts dom Sem approximants ctx
%%  LocalWords:  Hyland CDS polymorphism
