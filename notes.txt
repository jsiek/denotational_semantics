Correctness of the Delay pass

Denotations

D     infinite set of d's
Dᶠ     finite set of d's
d ::= Dᶠ ↦ d | ⟨d,...,d⟩ | ν

Application Operator

D₁ ▪ D₂ = { d | Dᶠ ↦ d ∈ D₁ and Dᶠ ⊆ D₂ and Dᶠ not empty}

Abstraction Operator

(Λ F) = {ν} ∪ { Dᶠ ↦ d | d ∈ F(Dᶠ) }

Source Language:

L,M,N ::= x | L(M) | λ x y. N @ M | ⟨ M₁ , ... , Mₙ ⟩ | L [ i ]

⟦ x ⟧ρ = ρ x
⟦ L(M) ⟧ρ = ⟦ L ⟧ρ ▪ ⟦ M ⟧ρ
⟦ λ x y. N @ M ⟧ρ = Λ D. ⟦ N ⟧ρ[x ↦ ⟦ M ⟧ρ][y ↦ D]
⟦ ⟨ M₁ , ... , Mₙ ⟩ ⟧ρ = { ⟨d₁,...,dₙ⟩ | for i=1..n, dᵢ ∈ ⟦ Mᵢ ⟧ρ }
⟦ L [ i ] ⟧ρ = { dᵢ | ⟨d₁,...,dₙ⟩ ∈ ⟦ L ⟧ρ }

Target Language:

L,M,N ::= x | L(M,N) | λ x y. N | ⟨ M₁ , ... , Mₙ ⟩ | M [ n ]

⟦ x ⟧ρ = ρ x
⟦ L(M,N) ⟧ρ = (⟦ L ⟧ρ ▪ ⟦ M ⟧ρ) ▪ ⟦ N ⟧ρ
⟦ λ x y. N ⟧ρ = Λ D₁. Λ D₂. ⟦ N ⟧ρ[x ↦ D₁][y ↦ D₂]
⟦ ⟨ M₁ , ... , Mₙ ⟩ ⟧ρ = { ⟨d₁,...,dₙ⟩ | for i=1..n, dᵢ ∈ ⟦ Mᵢ ⟧ρ }
⟦ L [ i ] ⟧ρ = { dᵢ | ⟨d₁,...,dₙ⟩ ∈ ⟦ L ⟧ρ }

Delay Pass

D(x)                 = x
D(L(M))              = let c = D(L) in c[0](c[1],M)
D(λ x y. N @ M)      = ⟨ λ x y. N , M ⟩
D(⟨ M₁ , ... , Mₙ ⟩) = ⟨ D(M₁) , ..., D(Mₙ) ⟩
D(L [ i ])           = D(L) [ i ]




================================================================================

determ:
  If X ∈ [e]ρ1 and Y ∈ [e]ρ2,
  then (X ∩ Y) ∈ [e](ρ1 ∩ ρ2).



strengthen:
  If X ∈ [e]ρ1 and X <: Y and ρ2 <: ρ1,
  then Y ∈ [e]ρ2.



(A → B) ∩ (C → D) ∈ [λ e]ρ
  A → B ∈ [λ e]ρ
    B ∈ [e]A#ρ
  C → D ∈ [λ e]ρ
    D ∈ [e]C#ρ

  A → B ~ C → D

  Case A ~ C:

    (B ∩ D) ∈ [e](A ∩ C)#ρ  by determ 
    (A ∩ C) → (B ∩ D) ∈ [λ e]ρ

  Case A /~ C:
    then they couldn't be supertypes of the same type



================================================================================

Γ |- A    Δ, A, Σ |- C 
----------------------
Δ, Γ, Σ |- C


case le_arrow le_arrow
A → B
C → D

Have:
A ⊦ c1 : dom(Γ)      C ⊦ c3 : dom(Δ), A, dom(Σ)
cod(Γ) ⊦ c2 : B      cod(Δ), B, cod(Σ) ⊦ c4 : D
---------------      --------------------------
Γ ⊦ A → B            Δ, A → B, Σ ⊦ C → D


Proof:

C ⊦ c3' : A   A ⊦ c1 : dom(Γ)
----------------------------(IH)
C ⊦ c4 : dom(Γ)
C ⊦ c3' : dom(Δ),dom(Σ)        cod(Γ) ⊦ c2 : B   cod(Δ),B,cod(Σ) ⊦ c4 : D
-------------------------      -----------------------------------------(IH)
C ⊦ dom(Δ), dom(Γ), dom(Σ)     cod(Δ), cod(Γ), cod(Σ) ⊦ D
---------------------------------------------------------(→)
Δ, Γ, Σ ⊦ C → D





================================================================================
Could P(N) (or B(A)) be used for semantic subtyping?
And avoid the need for the E and give inversion principles?


V = n | Pf(V) x V

A,B,C,D ::= n | A → B | A ∩ B

[n] = {n}
[A → B] = { (vs,v) | vs ⊆ [A] implies v ∈ [B] }
[A ∩ B] = [A] ∩ [B]

A <: B def= [A] ⊆ [B]


Suppose A → B <: C → D
  { (vs,v) | vs ⊆ [A] implies v ∈ [B] }
  ⊆
  { (vs,v) | vs ⊆ [C] implies v ∈ [D] }

nts C <: A
<=  [C] ⊆ [A]
  Suppose x ∈ [C].
  nts x ∈ [A].

